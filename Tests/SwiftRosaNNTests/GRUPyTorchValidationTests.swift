//
//  GRUPyTorchValidationTests.swift
//  SwiftRosaNNTests
//
//  Validates GRU implementation against PyTorch reference outputs.
//  Reference data generated by scripts/generate_gru_reference.py
//

import Foundation
import Metal
import MetalPerformanceShaders
import XCTest

@testable import SwiftRosaNN

final class GRUPyTorchValidationTests: XCTestCase {
    // Tolerance for PyTorch comparison
    // Using 1e-4 which is appropriate for float32 with accumulated operations
    private let tolerance: Float = 1e-4

    /// Get the path to the GRU reference data directory
    private func referenceDataURL(for name: String) -> URL? {
        // Try bundle first
        if let bundleURL = Bundle.module.url(
            forResource: name,
            withExtension: nil,
            subdirectory: "ReferenceData/gru"
        ) {
            return bundleURL
        }

        // Fallback to file system for development
        let projectRoot = URL(fileURLWithPath: #file)
            .deletingLastPathComponent()  // GRUPyTorchValidationTests.swift
            .deletingLastPathComponent()  // SwiftRosaNNTests
            .deletingLastPathComponent()  // Tests

        let path = projectRoot
            .appendingPathComponent("Tests")
            .appendingPathComponent("SwiftRosaNNTests")
            .appendingPathComponent("ReferenceData")
            .appendingPathComponent("gru")
            .appendingPathComponent(name)

        if FileManager.default.fileExists(atPath: path.path) {
            return path
        }

        return nil
    }

    /// Load float32 binary file
    private func loadFloats(from url: URL) throws -> [Float] {
        let data = try Data(contentsOf: url)
        let count = data.count / MemoryLayout<Float>.size
        var result = [Float](repeating: 0, count: count)
        _ = result.withUnsafeMutableBytes { destPtr in
            data.copyBytes(to: destPtr)
        }
        return result
    }

    /// Load metadata JSON
    private func loadMetadata(from refDir: URL) throws -> [String: Any] {
        let metadataURL = refDir.appendingPathComponent("metadata.json")
        let data = try Data(contentsOf: metadataURL)
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            throw NSError(domain: "GRUTest", code: 1, userInfo: [NSLocalizedDescriptionKey: "Invalid metadata"])
        }
        return json
    }

    // MARK: - Single Step Validation

    func testGRUCellSingleStepMatchesPyTorch() async throws {
        guard LSTMEngine.isAvailable else {
            throw XCTSkip("Metal not available")
        }

        guard let refDir = referenceDataURL(for: "single_step") else {
            throw XCTSkip("Reference data not found - run scripts/generate_gru_reference.py")
        }

        let engine = try LSTMEngine()

        // Load metadata
        let metadata = try loadMetadata(from: refDir)
        let inputSize = metadata["input_size"] as! Int
        let hiddenSize = metadata["hidden_size"] as! Int
        let batchSize = metadata["batch_size"] as! Int

        print("Single step test:")
        print("  inputSize: \(inputSize), hiddenSize: \(hiddenSize), batchSize: \(batchSize)")

        // Load reference data
        let weightIH = try loadFloats(from: refDir.appendingPathComponent("weight_ih.bin"))
        let weightHH = try loadFloats(from: refDir.appendingPathComponent("weight_hh.bin"))
        let biasIH = try loadFloats(from: refDir.appendingPathComponent("bias_ih.bin"))
        let biasHH = try loadFloats(from: refDir.appendingPathComponent("bias_hh.bin"))
        let input = try loadFloats(from: refDir.appendingPathComponent("input.bin"))
        let h0 = try loadFloats(from: refDir.appendingPathComponent("h0.bin"))
        let expectedH1 = try loadFloats(from: refDir.appendingPathComponent("expected_h1.bin"))

        print("  weightIH: \(weightIH.count), weightHH: \(weightHH.count)")

        // Create GRU weights
        let weights = GRULayerWeights(
            weightIH: weightIH,
            weightHH: weightHH,
            biasIH: biasIH,
            biasHH: biasHH,
            inputSize: inputSize,
            hiddenSize: hiddenSize
        )

        let config = GRUConfig(inputSize: inputSize, hiddenSize: hiddenSize)
        let cell = try await GRUCell(weights: weights, config: config, engine: engine)

        // Run forward pass
        let h1 = try await cell.forward(
            input: input,
            hPrev: h0,
            batchSize: batchSize
        )

        // Compare with PyTorch reference
        print("  Expected h1: \(expectedH1)")
        print("  Got h1:      \(h1)")

        XCTAssertEqual(h1.count, expectedH1.count, "Output size mismatch")

        var maxError: Float = 0
        for i in 0..<h1.count {
            let error = abs(h1[i] - expectedH1[i])
            maxError = max(maxError, error)
            XCTAssertEqual(
                h1[i],
                expectedH1[i],
                accuracy: tolerance,
                "Mismatch at index \(i): got \(h1[i]), expected \(expectedH1[i])"
            )
        }
        print("  Max error: \(maxError)")
    }

    // MARK: - Sequence Validation

    func testGRULayerSimpleMatchesPyTorch() async throws {
        guard LSTMEngine.isAvailable else {
            throw XCTSkip("Metal not available")
        }

        guard let refDir = referenceDataURL(for: "simple") else {
            throw XCTSkip("Reference data not found - run scripts/generate_gru_reference.py")
        }

        try await validateGRULayer(refDir: refDir, name: "simple", bidirectional: false)
    }

    func testGRULayerBidirectionalMatchesPyTorch() async throws {
        guard LSTMEngine.isAvailable else {
            throw XCTSkip("Metal not available")
        }

        guard let refDir = referenceDataURL(for: "bidirectional") else {
            throw XCTSkip("Reference data not found - run scripts/generate_gru_reference.py")
        }

        try await validateGRULayer(refDir: refDir, name: "bidirectional", bidirectional: true)
    }

    func testBiGRULayerBanquetSmallMatchesPyTorch() async throws {
        guard LSTMEngine.isAvailable else {
            throw XCTSkip("Metal not available")
        }

        guard let refDir = referenceDataURL(for: "banquet_small") else {
            throw XCTSkip("Reference data not found - run scripts/generate_gru_reference.py")
        }

        try await validateGRULayer(refDir: refDir, name: "banquet_small", bidirectional: true)
    }

    // MARK: - Helper

    private func validateGRULayer(refDir: URL, name: String, bidirectional: Bool) async throws {
        let engine = try LSTMEngine()

        // Load metadata
        let metadata = try loadMetadata(from: refDir)
        let inputSize = metadata["input_size"] as! Int
        let hiddenSize = metadata["hidden_size"] as! Int
        let batchSize = metadata["batch_size"] as! Int
        let seqLen = metadata["seq_len"] as! Int

        // Load weights
        let weightIH = try loadFloats(from: refDir.appendingPathComponent("weight_ih_l0.bin"))
        let weightHH = try loadFloats(from: refDir.appendingPathComponent("weight_hh_l0.bin"))
        let biasIH = try loadFloats(from: refDir.appendingPathComponent("bias_ih_l0.bin"))
        let biasHH = try loadFloats(from: refDir.appendingPathComponent("bias_hh_l0.bin"))

        // Load input and expected output
        let input = try loadFloats(from: refDir.appendingPathComponent("input.bin"))
        let expectedOutput = try loadFloats(from: refDir.appendingPathComponent("expected_output.bin"))

        print("\(name) test:")
        print("  inputSize: \(inputSize), hiddenSize: \(hiddenSize)")
        print("  batchSize: \(batchSize), seqLen: \(seqLen)")
        print("  bidirectional: \(bidirectional)")

        let forwardWeights = GRULayerWeights(
            weightIH: weightIH,
            weightHH: weightHH,
            biasIH: biasIH,
            biasHH: biasHH,
            inputSize: inputSize,
            hiddenSize: hiddenSize
        )

        let config = GRUConfig(
            inputSize: inputSize,
            hiddenSize: hiddenSize,
            bidirectional: bidirectional
        )

        let output: [Float]

        if bidirectional {
            // Load backward weights
            let weightIHReverse = try loadFloats(
                from: refDir.appendingPathComponent("weight_ih_l0_reverse.bin")
            )
            let weightHHReverse = try loadFloats(
                from: refDir.appendingPathComponent("weight_hh_l0_reverse.bin")
            )
            let biasIHReverse = try loadFloats(
                from: refDir.appendingPathComponent("bias_ih_l0_reverse.bin")
            )
            let biasHHReverse = try loadFloats(
                from: refDir.appendingPathComponent("bias_hh_l0_reverse.bin")
            )

            let backwardWeights = GRULayerWeights(
                weightIH: weightIHReverse,
                weightHH: weightHHReverse,
                biasIH: biasIHReverse,
                biasHH: biasHHReverse,
                inputSize: inputSize,
                hiddenSize: hiddenSize
            )

            let bigru = try await BiGRULayer(
                forwardWeights: forwardWeights,
                backwardWeights: backwardWeights,
                config: config,
                engine: engine
            )

            let (out, _) = try await bigru.forward(
                input,
                batchSize: batchSize,
                seqLen: seqLen
            )
            output = out
        } else {
            let layer = try await GRULayer(
                weights: forwardWeights,
                config: config,
                engine: engine
            )

            let (out, _) = try await layer.forward(
                input,
                batchSize: batchSize,
                seqLen: seqLen
            )
            output = out
        }

        // Compare outputs
        XCTAssertEqual(output.count, expectedOutput.count, "Output size mismatch")

        var maxError: Float = 0
        var errorCount = 0
        for i in 0..<output.count {
            let error = abs(output[i] - expectedOutput[i])
            maxError = max(maxError, error)
            if error > tolerance {
                errorCount += 1
                if errorCount <= 5 {
                    print("  Mismatch at \(i): got \(output[i]), expected \(expectedOutput[i]), error: \(error)")
                }
            }
        }

        print("  Max error: \(maxError)")
        print("  Errors > tolerance: \(errorCount) / \(output.count)")

        // Final assertion
        for i in 0..<output.count {
            XCTAssertEqual(
                output[i],
                expectedOutput[i],
                accuracy: tolerance,
                "Output mismatch at index \(i)"
            )
        }
    }
}
