import XCTest
@testable import SwiftRosaCore
import SwiftRosaEffects

/// Tests that compare Swift implementations against librosa reference values.
///
/// These tests load ground truth values generated by librosa and verify
/// numerical agreement within justified tolerances.
///
/// **Tolerance Justification:**
/// - FFT operations: 1e-5 (Float32 precision, ~7 significant digits)
/// - Log/exp operations: 1e-4 (accumulated floating-point error)
/// - Matrix multiply: 1e-4 (error grows with dimensions)
/// - Iterative algorithms (Griffin-Lim): 1e-2 after convergence
final class LibrosaComparisonTests: XCTestCase {

    // MARK: - Reference Data Loading

    private static var referenceData: [String: Any]?

    override class func setUp() {
        super.setUp()
        loadReferenceData()
    }

    private static func loadReferenceData() {
        let bundle = Bundle(for: LibrosaComparisonTests.self)

        // Try multiple paths to find the reference data
        let possiblePaths = [
            bundle.path(forResource: "librosa_reference", ofType: "json"),
            bundle.resourcePath.map { $0 + "/ReferenceData/librosa_reference.json" },
            // Direct path for SPM tests
            URL(fileURLWithPath: #file)
                .deletingLastPathComponent()
                .appendingPathComponent("../ReferenceData/librosa_reference.json")
                .path
        ].compactMap { $0 }

        for path in possiblePaths {
            if FileManager.default.fileExists(atPath: path),
               let data = FileManager.default.contents(atPath: path),
               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                referenceData = json
                return
            }
        }

        // Fallback: try working directory path
        let workingPath = FileManager.default.currentDirectoryPath
        let fallbackPath = workingPath + "/Tests/ReferenceData/librosa_reference.json"
        if let data = FileManager.default.contents(atPath: fallbackPath),
           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            referenceData = json
        }
    }

    private func getReference() throws -> [String: Any] {
        guard let ref = Self.referenceData else {
            throw XCTSkip("Reference data not found. Run scripts/generate_reference_data.py first.")
        }
        return ref
    }

    // MARK: - Mel Scale Conversion Tests

    /// Test Hz to Mel conversion matches librosa (HTK formula)
    func testMelScaleHTK() throws {
        let ref = try getReference()
        guard let melScaleRef = ref["mel_scale"] as? [String: Any],
              let htkRef = melScaleRef["htk"] as? [String: Any],
              let testFreqs = melScaleRef["test_frequencies_hz"] as? [Double],
              let expectedMels = htkRef["mel_values"] as? [Double] else {
            throw XCTSkip("Mel scale reference data not found")
        }

        // HTK formula: mel = 2595 * log10(1 + hz/700)
        for (hz, expectedMel) in zip(testFreqs, expectedMels) {
            let calculatedMel = 2595.0 * log10(1.0 + hz / 700.0)
            XCTAssertEqual(calculatedMel, expectedMel, accuracy: 1e-3,
                "HTK mel conversion failed for \(hz) Hz: expected \(expectedMel), got \(calculatedMel)")
        }
    }

    /// Test Hz to Mel conversion matches librosa (Slaney formula)
    func testMelScaleSlaney() throws {
        let ref = try getReference()
        guard let melScaleRef = ref["mel_scale"] as? [String: Any],
              let slaneyRef = melScaleRef["slaney"] as? [String: Any],
              let testFreqs = melScaleRef["test_frequencies_hz"] as? [Double],
              let expectedMels = slaneyRef["mel_values"] as? [Double] else {
            throw XCTSkip("Mel scale reference data not found")
        }

        // Slaney formula:
        // Below 1000 Hz: mel = hz * 3/200
        // Above 1000 Hz: mel = 15 + log(hz/1000) / log(6.4) * 27
        let fSp = 200.0 / 3.0  // ~66.667
        let minLogHz = 1000.0
        let minLogMel = minLogHz / fSp  // 15
        let logStep = log(6.4) / 27.0

        for (hz, expectedMel) in zip(testFreqs, expectedMels) {
            let calculatedMel: Double
            if hz < minLogHz {
                calculatedMel = hz / fSp
            } else {
                calculatedMel = minLogMel + log(hz / minLogHz) / logStep
            }
            XCTAssertEqual(calculatedMel, expectedMel, accuracy: 1e-3,
                "Slaney mel conversion failed for \(hz) Hz: expected \(expectedMel), got \(calculatedMel)")
        }
    }

    // MARK: - Window Function Tests

    /// Test Hann window matches scipy
    func testHannWindowPeriodic() throws {
        let ref = try getReference()
        guard let windowsRef = ref["windows"] as? [String: Any],
              let windows = windowsRef["windows"] as? [String: [Double]],
              let expectedHann = windows["hann_periodic"],
              let windowLength = windowsRef["window_length"] as? Int else {
            throw XCTSkip("Window reference data not found")
        }

        // Generate our Hann window
        let ourWindow = Windows.generate(.hann, length: windowLength, periodic: true)

        XCTAssertEqual(ourWindow.count, expectedHann.count,
            "Window length mismatch: expected \(expectedHann.count), got \(ourWindow.count)")

        for (i, (expected, actual)) in zip(expectedHann, ourWindow).enumerated() {
            XCTAssertEqual(Double(actual), expected, accuracy: 1e-6,
                "Hann window mismatch at index \(i): expected \(expected), got \(actual)")
        }
    }

    /// Test Hamming window matches scipy
    func testHammingWindowPeriodic() throws {
        let ref = try getReference()
        guard let windowsRef = ref["windows"] as? [String: Any],
              let windows = windowsRef["windows"] as? [String: [Double]],
              let expectedHamming = windows["hamming_periodic"],
              let windowLength = windowsRef["window_length"] as? Int else {
            throw XCTSkip("Window reference data not found")
        }

        let ourWindow = Windows.generate(.hamming, length: windowLength, periodic: true)

        XCTAssertEqual(ourWindow.count, expectedHamming.count)

        for (i, (expected, actual)) in zip(expectedHamming, ourWindow).enumerated() {
            XCTAssertEqual(Double(actual), expected, accuracy: 1e-6,
                "Hamming window mismatch at index \(i): expected \(expected), got \(actual)")
        }
    }

    /// Test Blackman window matches scipy
    func testBlackmanWindowPeriodic() throws {
        let ref = try getReference()
        guard let windowsRef = ref["windows"] as? [String: Any],
              let windows = windowsRef["windows"] as? [String: [Double]],
              let expectedBlackman = windows["blackman_periodic"],
              let windowLength = windowsRef["window_length"] as? Int else {
            throw XCTSkip("Window reference data not found")
        }

        let ourWindow = Windows.generate(.blackman, length: windowLength, periodic: true)

        XCTAssertEqual(ourWindow.count, expectedBlackman.count)

        for (i, (expected, actual)) in zip(expectedBlackman, ourWindow).enumerated() {
            XCTAssertEqual(Double(actual), expected, accuracy: 1e-6,
                "Blackman window mismatch at index \(i): expected \(expected), got \(actual)")
        }
    }

    // MARK: - STFT Tests

    /// Test STFT magnitude matches librosa for sine wave
    func testSTFTMagnitudeSine440() async throws {
        let ref = try getReference()
        guard let stftRef = ref["stft"] as? [String: Any],
              let sineRef = stftRef["sine_440hz"] as? [String: Any],
              let expectedMagnitude = sineRef["magnitude"] as? [[Double]],
              let nFFT = sineRef["n_fft"] as? Int,
              let hopLength = sineRef["hop_length"] as? Int else {
            throw XCTSkip("STFT reference data not found")
        }

        // Generate the same test signal
        let sampleRate = 22050
        let duration = 1.0
        let nSamples = Int(Double(sampleRate) * duration)
        var signal = [Float](repeating: 0, count: nSamples)
        for i in 0..<nSamples {
            signal[i] = sin(2 * Float.pi * 440 * Float(i) / Float(sampleRate))
        }

        // Compute STFT with matching parameters
        let config = STFTConfig(
            nFFT: nFFT,
            hopLength: hopLength,
            winLength: nFFT,
            windowType: .hann,
            center: true,
            padMode: .constant(0)
        )
        let stft = STFT(config: config)
        let result = await stft.transform(signal)
        let magnitude = result.magnitude

        // Expected shape: (nFrames, nFreqs) from librosa (transposed)
        let nFrames = expectedMagnitude.count
        let nFreqs = expectedMagnitude.first?.count ?? 0

        XCTAssertEqual(result.cols, nFrames, accuracy: 2,
            "Number of frames mismatch: expected ~\(nFrames), got \(result.cols)")

        // Compare a subset of frames to validate numerical agreement
        // Use absolute error for small values, relative error for large values
        let framesToCompare = min(10, nFrames)
        var maxAbsError: Double = 0
        var maxRelError: Double = 0
        var errorCount = 0

        for frameIdx in 0..<min(framesToCompare, magnitude.first?.count ?? 0) {
            let expectedFrame = expectedMagnitude[frameIdx]
            for freqIdx in 0..<min(nFreqs, magnitude.count) {
                let expected = expectedFrame[freqIdx]
                let actual = Double(magnitude[freqIdx][frameIdx])
                let absError = Swift.abs(expected - actual)
                maxAbsError = Swift.max(maxAbsError, absError)

                // Only compute relative error for significant values
                if Swift.abs(expected) > 1.0 {
                    let relError = absError / Swift.abs(expected)
                    maxRelError = Swift.max(maxRelError, relError)
                }
                errorCount += 1
            }
        }

        // FFT operations should have relative error < 1e-4 for Float32
        XCTAssertLessThan(maxRelError, 1e-4,
            "STFT magnitude max relative error too high: \(maxRelError)")
        XCTAssertLessThan(maxAbsError, 0.01,
            "STFT magnitude max absolute error too high: \(maxAbsError)")
    }

    // MARK: - Mel Filterbank Tests

    /// Test Mel filterbank shape and normalization matches librosa
    func testMelFilterbank128() throws {
        let ref = try getReference()
        guard let melRef = ref["mel_filterbank"] as? [String: Any],
              let ref128 = melRef["128_mels"] as? [String: Any],
              let expectedFilterbank = ref128["filterbank"] as? [[Double]],
              let shape = ref128["shape"] as? [Int] else {
            throw XCTSkip("Mel filterbank reference data not found")
        }

        let nMels = shape[0]
        let nFreqs = shape[1]

        // Create filterbank with same parameters
        let filterbank = MelFilterbank(
            nMels: nMels,
            nFFT: 2048,
            sampleRate: 22050,
            fMin: 0,
            fMax: 22050 / 2,
            htk: false,
            norm: .slaney
        )

        let filters = filterbank.filters()

        XCTAssertEqual(filters.count, nMels,
            "Number of mel filters mismatch: expected \(nMels), got \(filters.count)")

        // Compare filterbank values
        var maxError: Double = 0
        for melIdx in 0..<min(nMels, filters.count) {
            let expectedFilter = expectedFilterbank[melIdx]
            let actualFilter = filters[melIdx]

            for freqIdx in 0..<min(nFreqs, actualFilter.count) {
                let expected = expectedFilter[freqIdx]
                let actual = Double(actualFilter[freqIdx])

                // For non-zero values, check relative error
                if expected > 1e-10 {
                    let error = abs(expected - actual) / expected
                    maxError = max(maxError, error)
                } else {
                    // For near-zero values, check absolute error
                    let error = abs(expected - actual)
                    if error > 1e-6 {
                        maxError = max(maxError, error)
                    }
                }
            }
        }

        XCTAssertLessThan(maxError, 0.01,
            "Mel filterbank max relative error too high: \(maxError)")
    }

    // MARK: - MFCC Tests

    /// Test MFCC computation matches librosa for sine wave
    func testMFCCSine440() async throws {
        let ref = try getReference()
        guard let mfccRef = ref["mfcc"] as? [String: Any],
              let sineRef = mfccRef["sine_440hz"] as? [String: Any],
              let expectedMFCC = sineRef["mfcc"] as? [[Double]],
              let nMFCC = sineRef["n_mfcc"] as? Int,
              let nFFT = sineRef["n_fft"] as? Int,
              let hopLength = sineRef["hop_length"] as? Int,
              let nMels = sineRef["n_mels"] as? Int else {
            throw XCTSkip("MFCC reference data not found")
        }

        // Generate the same test signal
        let sampleRate: Float = 22050
        let duration: Float = 1.0
        let nSamples = Int(sampleRate * duration)
        var signal = [Float](repeating: 0, count: nSamples)
        for i in 0..<nSamples {
            signal[i] = sin(2 * Float.pi * 440 * Float(i) / sampleRate)
        }

        // Compute MFCC with matching parameters
        let mfcc = MFCC(
            sampleRate: sampleRate,
            nFFT: nFFT,
            hopLength: hopLength,
            nMels: nMels,
            nMFCC: nMFCC,
            fMin: 0,
            fMax: nil,  // defaults to sr/2
            lifter: 0  // no liftering
        )
        let result = await mfcc.transform(signal)

        // Expected shape: (nFrames, nCoeffs) from librosa (transposed)
        let nFrames = expectedMFCC.count

        XCTAssertEqual(result[0].count, nFrames, accuracy: 2,
            "Number of frames mismatch: expected ~\(nFrames), got \(result[0].count)")

        // Note: Our MFCC implementation uses natural log (ln) while librosa uses
        // power_to_db (10 * log10 with max reference). The implementations differ
        // by a scale factor and offset. Instead of exact matching, we verify:
        // 1. The relative shape of coefficients is similar (ratios between coefficients)
        // 2. Higher-order coefficients have smaller magnitudes (expected for MFCCs)
        // 3. The temporal evolution is consistent

        // Verify coefficient structure: higher indices should have smaller magnitudes on average
        var ourAvgMagnitudes = [Float](repeating: 0, count: nMFCC)
        var refAvgMagnitudes = [Double](repeating: 0, count: nMFCC)

        let framesToCompare = min(10, result.first?.count ?? 0, expectedMFCC.count)
        for frameIdx in 0..<framesToCompare {
            let expectedFrame = expectedMFCC[frameIdx]
            for coeffIdx in 0..<min(nMFCC, result.count, expectedFrame.count) {
                ourAvgMagnitudes[coeffIdx] += Swift.abs(result[coeffIdx][frameIdx])
                refAvgMagnitudes[coeffIdx] += Swift.abs(expectedFrame[coeffIdx])
            }
        }

        // Verify that both implementations show decreasing magnitude trend for higher coefficients
        // (This is a fundamental property of MFCCs derived from cepstral analysis)
        let middleIdx = nMFCC / 2
        let ourHigherAvg = ourAvgMagnitudes[middleIdx...].reduce(0, +) / Float(nMFCC - middleIdx)
        let ourLowerAvg = ourAvgMagnitudes[1..<middleIdx].reduce(0, +) / Float(middleIdx - 1)

        XCTAssertLessThan(ourHigherAvg, ourLowerAvg * 2,
            "Higher MFCC coefficients should generally have smaller magnitude")

        // Verify the first coefficient (energy) is large for both
        XCTAssertGreaterThan(Swift.abs(result[0][framesToCompare / 2]), 1.0,
            "MFCC coefficient 0 (energy) should be significant")
        XCTAssertGreaterThan(Swift.abs(expectedMFCC[framesToCompare / 2][0]), 1.0,
            "Reference MFCC coefficient 0 should be significant")

        // Verify correlation between our implementation and librosa (ignoring scale)
        // The shape/pattern should be similar even if absolute values differ

        // Normalize to unit variance for comparison
        let testFrame = framesToCompare / 2
        var ourMean: Float = 0
        var refMean: Double = 0

        for coeffIdx in 0..<min(nMFCC, result.count, expectedMFCC[testFrame].count) {
            ourMean += result[coeffIdx][testFrame]
            refMean += expectedMFCC[testFrame][coeffIdx]
        }
        ourMean /= Float(nMFCC)
        refMean /= Double(nMFCC)

        var ourVar: Float = 0
        var refVar: Double = 0
        for coeffIdx in 0..<min(nMFCC, result.count, expectedMFCC[testFrame].count) {
            let ourDiff = result[coeffIdx][testFrame] - ourMean
            let refDiff = expectedMFCC[testFrame][coeffIdx] - refMean
            ourVar += ourDiff * ourDiff
            refVar += refDiff * refDiff
        }

        let ourStd = sqrt(ourVar / Float(nMFCC))
        let refStd = sqrt(refVar / Double(nMFCC))

        // Compute correlation
        var correlation: Double = 0
        for coeffIdx in 0..<min(nMFCC, result.count, expectedMFCC[testFrame].count) {
            let ourZ = Double(result[coeffIdx][testFrame] - ourMean) / Double(ourStd)
            let refZ = (expectedMFCC[testFrame][coeffIdx] - refMean) / refStd
            correlation += ourZ * refZ
        }
        correlation /= Double(nMFCC)

        // High correlation indicates similar coefficient patterns
        XCTAssertGreaterThan(correlation, 0.9,
            "MFCC correlation with librosa should be high (got \(correlation))")
    }

    // MARK: - Spectral Features Tests

    /// Test spectral centroid matches librosa
    func testSpectralCentroidSine440() async throws {
        let ref = try getReference()
        guard let spectralRef = ref["spectral_features"] as? [String: Any],
              let sineRef = spectralRef["sine_440hz"] as? [String: Any],
              let expectedCentroid = sineRef["centroid"] as? [Double],
              let nFFT = sineRef["n_fft"] as? Int,
              let hopLength = sineRef["hop_length"] as? Int else {
            throw XCTSkip("Spectral features reference data not found")
        }

        // Generate the same test signal
        let sampleRate: Float = 22050
        let nSamples = Int(sampleRate * 1.0)
        var signal = [Float](repeating: 0, count: nSamples)
        for i in 0..<nSamples {
            signal[i] = sin(2 * Float.pi * 440 * Float(i) / sampleRate)
        }

        // Compute spectral centroid
        let config = SpectralFeaturesConfig(
            sampleRate: sampleRate,
            nFFT: nFFT,
            hopLength: hopLength
        )
        let features = SpectralFeatures(config: config)
        let centroids = await features.centroid(signal)

        XCTAssertEqual(centroids.count, expectedCentroid.count, accuracy: 2,
            "Centroid frame count mismatch")

        // For a 440 Hz sine wave, centroid should be near 440 Hz
        // However, edge frames may vary due to windowing effects
        // Focus on middle frames where the signal is stable
        let startFrame = min(2, centroids.count - 1)
        let endFrame = min(startFrame + 3, centroids.count, expectedCentroid.count)

        for i in startFrame..<endFrame {
            let expected = Float(expectedCentroid[i])
            let actual = centroids[i]

            // Allow 10% relative error for spectral centroid
            // Edge effects and windowing can cause variations
            if expected > 100 {
                let error = Swift.abs(expected - actual) / expected
                XCTAssertLessThan(error, 0.10,
                    "Spectral centroid frame \(i): expected \(expected), got \(actual)")
            }
        }

        // Also verify the centroid is approximately 440 Hz for a 440 Hz sine
        let middleIdx = centroids.count / 2
        if middleIdx < centroids.count {
            XCTAssertEqual(centroids[middleIdx], 440.0, accuracy: 50.0,
                "Centroid should be near 440 Hz for a pure 440 Hz sine")
        }
    }

    /// Test spectral flatness matches librosa
    func testSpectralFlatnessSine440() async throws {
        let ref = try getReference()
        guard let spectralRef = ref["spectral_features"] as? [String: Any],
              let sineRef = spectralRef["sine_440hz"] as? [String: Any],
              let expectedFlatness = sineRef["flatness"] as? [Double],
              let nFFT = sineRef["n_fft"] as? Int,
              let hopLength = sineRef["hop_length"] as? Int else {
            throw XCTSkip("Spectral features reference data not found")
        }

        // Generate the same test signal
        let sampleRate: Float = 22050
        let nSamples = Int(sampleRate * 1.0)
        var signal = [Float](repeating: 0, count: nSamples)
        for i in 0..<nSamples {
            signal[i] = sin(2 * Float.pi * 440 * Float(i) / sampleRate)
        }

        let config = SpectralFeaturesConfig(
            sampleRate: sampleRate,
            nFFT: nFFT,
            hopLength: hopLength
        )
        let features = SpectralFeatures(config: config)
        let flatness = await features.flatness(signal)

        // Pure sine should have very low flatness (near 0)
        // White noise would have flatness near 1
        // Check middle frames where signal is stable
        let middleIdx = flatness.count / 2
        if middleIdx < flatness.count && middleIdx > 0 {
            let avgFlatness = (flatness[middleIdx - 1] + flatness[middleIdx] + flatness[min(middleIdx + 1, flatness.count - 1)]) / 3.0
            XCTAssertLessThan(avgFlatness, 0.1,
                "Sine wave should have low spectral flatness in middle frames, got \(avgFlatness)")
        }

        // For spectral flatness, both librosa and our implementation should give low values
        // for a pure sine wave, but the exact values can differ significantly based on
        // implementation details (epsilon handling, log domain, etc.)
        // The key invariant is: sine wave = low flatness, noise = high flatness
        let refMiddle = expectedFlatness.count / 2
        let refFlatness = Float(expectedFlatness[refMiddle])
        let ourFlatness = flatness[middleIdx]

        // Both should be "low" (< 0.2 for a pure tone)
        XCTAssertLessThan(refFlatness, 0.2, "Reference flatness should be low for sine")
        XCTAssertLessThan(ourFlatness, 0.2, "Our flatness should be low for sine")
    }

    // MARK: - Griffin-Lim Reference Test

    /// Test Griffin-Lim spectral error is within expected range
    func testGriffinLimSpectralError() async throws {
        let ref = try getReference()
        guard let glRef = ref["griffin_lim"] as? [String: Any],
              let expectedError = glRef["spectral_error"] as? Double,
              let nFFT = glRef["n_fft"] as? Int,
              let hopLength = glRef["hop_length"] as? Int,
              let _ = glRef["n_iter"] as? Int else {
            throw XCTSkip("Griffin-Lim reference data not found")
        }

        // Generate a short test signal
        let nSamples = 1024
        var signal = [Float](repeating: 0, count: nSamples)
        for i in 0..<nSamples {
            signal[i] = sin(0.1 * Float(i))
        }

        // Compute STFT magnitude
        let config = STFTConfig(
            nFFT: nFFT,
            hopLength: hopLength,
            windowType: .hann,
            center: true,
            padMode: .constant(0)
        )
        let stft = STFT(config: config)
        let spectrogram = await stft.transform(signal)
        let magnitude = spectrogram.magnitude

        // Reconstruct with Griffin-Lim
        let griffinLim = GriffinLim(config: config)
        let reconstructed = await griffinLim.reconstruct(
            magnitude,
            length: nSamples
        )

        // Compute spectral error
        let reconstructedSpec = await stft.transform(reconstructed)
        let reconstructedMag = reconstructedSpec.magnitude

        var sumSquaredError: Float = 0
        var sumSquaredRef: Float = 0

        for f in 0..<min(magnitude.count, reconstructedMag.count) {
            for t in 0..<min(magnitude[f].count, reconstructedMag[f].count) {
                let diff: Float = magnitude[f][t] - reconstructedMag[f][t]
                sumSquaredError += diff * diff
                sumSquaredRef += magnitude[f][t] * magnitude[f][t]
            }
        }

        let spectralError = sqrt(sumSquaredError / sumSquaredRef)

        // Our implementation should achieve similar or better error than librosa
        // Allow some tolerance since random initialization affects results
        XCTAssertLessThan(Double(spectralError), expectedError * 2.0,
            "Griffin-Lim spectral error \(spectralError) exceeds 2x reference \(expectedError)")
    }

    // MARK: - Resampling Tests

    /// Test resampling produces expected output length
    func testResamplingLength() async throws {
        let ref = try getReference()
        guard let resampleRef = ref["resample"] as? [String: Any],
              let ref44to22 = resampleRef["44100_to_22050"] as? [String: Any],
              let originalLength = ref44to22["original_length"] as? Int,
              let expectedLength = ref44to22["resampled_length"] as? Int else {
            throw XCTSkip("Resampling reference data not found")
        }

        // Generate test signal of same length
        var signal = [Float](repeating: 0, count: originalLength)
        for i in 0..<originalLength {
            signal[i] = sin(2 * Float.pi * 440 * Float(i) / 44100)
        }

        let resampled = await Resample.resample(
            signal,
            fromSampleRate: 44100,
            toSampleRate: 22050,
            quality: .high
        )

        // Output length should match expected (within 1-2 samples due to filter edge effects)
        XCTAssertEqual(resampled.count, expectedLength, accuracy: 5,
            "Resampled length mismatch: expected \(expectedLength), got \(resampled.count)")
    }

    /// Test resampling preserves signal energy approximately
    func testResamplingEnergy() async throws {
        let ref = try getReference()
        guard let resampleRef = ref["resample"] as? [String: Any],
              let ref22to16 = resampleRef["22050_to_16000"] as? [String: Any],
              let expectedEnergy = ref22to16["resampled_energy"] as? Double else {
            throw XCTSkip("Resampling reference data not found")
        }

        // Generate same test signal (440 Hz sine at 22050 Hz)
        let sampleRate = 22050
        let nSamples = sampleRate  // 1 second
        var signal = [Float](repeating: 0, count: nSamples)
        for i in 0..<nSamples {
            signal[i] = sin(2 * Float.pi * 440 * Float(i) / Float(sampleRate))
        }

        let resampled = await Resample.resample(
            signal,
            fromSampleRate: 22050,
            toSampleRate: 16000,
            quality: .high
        )

        // Calculate energy
        var energy: Float = 0
        for sample in resampled {
            energy += sample * sample
        }

        // Energy should be preserved (within 10% due to filter characteristics)
        let energyRatio = Double(energy) / expectedEnergy
        XCTAssertGreaterThan(energyRatio, 0.9, "Energy too low after resampling")
        XCTAssertLessThan(energyRatio, 1.1, "Energy too high after resampling")
    }
}
